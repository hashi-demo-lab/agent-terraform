"""
Node functions for Terraform Code Generation Agent
LangGraph Platform compatible node implementations
"""

import uuid
from datetime import datetime
from typing import Literal, Dict, Any
from langchain_core.messages import HumanMessage, AIMessage

from .state import TerraformState, WorkflowStatus, ValidationStatus, RequirementSpec


def planner_node(state: TerraformState) -> TerraformState:
    """
    Planner agent node - analyzes requirements and creates execution plan
    """
    # Initialize workflow if not already done
    if not state.get("workflow_id"):
        state["workflow_id"] = str(uuid.uuid4())
        state["thread_id"] = f"terraform_{state['workflow_id']}"
        state["start_time"] = datetime.now()
    
    state["current_agent"] = "planner"
    state["status"] = WorkflowStatus.RUNNING
    
    # Add planning message
    planning_message = AIMessage(
        content="Analyzing requirements and creating Terraform generation plan...",
        additional_kwargs={"agent": "planner", "step": "planning"}
    )
    state["messages"].append(planning_message)
    
    # Initialize context_memory if it doesn't exist
    if "context_memory" not in state:
        state["context_memory"] = {}
    
    # Extract requirements if provided
    requirements = state.get("requirements")
    if requirements:
        # Process requirements and create plan
        plan_details = f"""
        Planning Terraform infrastructure for:
        - Provider: {requirements.provider}
        - Environment: {requirements.environment}
        - Resources: {len(requirements.resources)} resource types
        - Compliance: {len(requirements.compliance_requirements)} requirements
        """
        
        state["context_memory"]["plan"] = {
            "provider": requirements.provider,
            "environment": requirements.environment,
            "resource_count": len(requirements.resources),
            "compliance_count": len(requirements.compliance_requirements)
        }
    else:
        plan_details = "No specific requirements provided. Using default planning approach."
        state["context_memory"]["plan"] = {"provider": "aws", "environment": "dev"}
    
    # Add plan to messages
    plan_message = AIMessage(
        content=plan_details,
        additional_kwargs={"agent": "planner", "step": "plan_created"}
    )
    state["messages"].append(plan_message)
    
    return state


def generator_node(state: TerraformState) -> TerraformState:
    """
    Generator agent node - generates Terraform code based on requirements
    """
    state["current_agent"] = "generator"
    
    # Get plan from context
    plan = state.get("context_memory", {}).get("plan", {})
    provider = plan.get("provider", "aws")
    environment = plan.get("environment", "dev")
    
    # Generate basic Terraform code
    terraform_code = f"""
# Terraform configuration for {environment} environment
# Generated by Terraform Code Generation Agent

terraform {{
  required_version = ">= 1.0"
  required_providers {{
    {provider} = {{
      source  = "hashicorp/{provider}"
      version = "~> 5.0"
    }}
  }}
}}

provider "{provider}" {{
  region = var.aws_region
  
  default_tags {{
    tags = local.common_tags
  }}
}}

# Variables
variable "environment" {{
  description = "Environment name (e.g., dev, staging, prod)"
  type        = string
  default     = "{environment}"
  validation {{
    condition     = contains(["dev", "staging", "prod"], var.environment)
    error_message = "Environment must be dev, staging, or prod."
  }}
}}

variable "aws_region" {{
  description = "AWS region for resources"
  type        = string
  default     = "us-west-2"
}}

variable "project_name" {{
  description = "Name of the project"
  type        = string
  default     = "terraform-agent-generated"
}}

# Local values
locals {{
  common_tags = {{
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "terraform"
    CreatedBy   = "terraform-agent"
  }}
}}

# Example S3 bucket resource
resource "aws_s3_bucket" "example" {{
  bucket = "${{var.project_name}}-${{var.environment}}-${{random_id.bucket_suffix.hex}}"
}}

resource "random_id" "bucket_suffix" {{
  byte_length = 4
}}

resource "aws_s3_bucket_versioning" "example" {{
  bucket = aws_s3_bucket.example.id
  versioning_configuration {{
    status = "Enabled"
  }}
}}

resource "aws_s3_bucket_server_side_encryption_configuration" "example" {{
  bucket = aws_s3_bucket.example.id
  
  rule {{
    apply_server_side_encryption_by_default {{
      sse_algorithm = "AES256"
    }}
  }}
}}

resource "aws_s3_bucket_public_access_block" "example" {{
  bucket = aws_s3_bucket.example.id
  
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}}

# Outputs
output "bucket_name" {{
  description = "Name of the created S3 bucket"
  value       = aws_s3_bucket.example.bucket
}}

output "bucket_arn" {{
  description = "ARN of the created S3 bucket"
  value       = aws_s3_bucket.example.arn
}}
"""
    
    state["generated_code"] = terraform_code
    
    # Add generation message
    generation_message = AIMessage(
        content=f"Generated Terraform code for {provider} provider in {environment} environment",
        additional_kwargs={"agent": "generator", "step": "code_generated", "lines": len(terraform_code.split('\n'))}
    )
    state["messages"].append(generation_message)
    
    return state


def validator_node(state: TerraformState) -> TerraformState:
    """
    Validator agent node - prepares code for validation tools
    """
    state["current_agent"] = "validator"
    
    # Get the generated code to validate
    generated_code = state.get("generated_code", "")
    
    if not generated_code:
        # No code to validate
        validation_message = AIMessage(
            content="No generated code found for validation",
            additional_kwargs={"agent": "validator", "step": "validation_skipped"}
        )
        state["messages"].append(validation_message)
        return state
    
    # Prepare validation message
    validation_message = AIMessage(
        content="Preparing code for validation tools...",
        additional_kwargs={"agent": "validator", "step": "validation_prepared"}
    )
    state["messages"].append(validation_message)
    
    # The actual validation will be done by the validation_tools ToolNode
    # This node just prepares the state for validation
    return state


def refiner_node(state: TerraformState) -> TerraformState:
    """
    Refiner agent node - refines code based on validation feedback
    """
    state["current_agent"] = "refiner"
    state["iteration_count"] = state.get("iteration_count", 0) + 1
    
    # Get current code and validation results
    current_code = state.get("generated_code", "")
    validation_results = state.get("validation_results", [])
    
    # Simulate refinement (in real implementation, this would apply fixes)
    refined_code = current_code + "\n# Code refined based on validation feedback\n"
    state["refined_code"] = refined_code
    state["generated_code"] = refined_code  # Update the main code
    
    # Add refinement message
    refinement_message = AIMessage(
        content=f"Code refined (iteration {state['iteration_count']})",
        additional_kwargs={"agent": "refiner", "step": "code_refined"}
    )
    state["messages"].append(refinement_message)
    
    return state


def analyzer_node(state: TerraformState) -> TerraformState:
    """
    Analyzer agent node - performs deep analysis of code and requirements
    """
    state["current_agent"] = "analyzer"
    
    # Simulate analysis
    analysis_results = {
        "complexity_score": 7.5,
        "security_score": 9.0,
        "compliance_score": 8.5,
        "issues_found": [],
        "recommendations": [
            "Consider adding more comprehensive tagging",
            "Add monitoring and alerting resources",
            "Implement backup strategies"
        ]
    }
    
    state["analysis_results"] = analysis_results
    
    # Add analysis message
    analysis_message = AIMessage(
        content=f"Analysis completed - Security: {analysis_results['security_score']}/10, Compliance: {analysis_results['compliance_score']}/10",
        additional_kwargs={"agent": "analyzer", "step": "analysis_completed"}
    )
    state["messages"].append(analysis_message)
    
    return state



def reviewer_node(state: TerraformState) -> TerraformState:
    """
    Reviewer agent node - final review and quality assurance
    """
    state["current_agent"] = "reviewer"
    state["status"] = WorkflowStatus.COMPLETED
    state["end_time"] = datetime.now()
    
    # Calculate execution metrics
    if state.get("start_time"):
        execution_time = (state["end_time"] - state["start_time"]).total_seconds()
        state["execution_metrics"]["total_execution_time"] = execution_time
    
    # Final review
    review_message = AIMessage(
        content="Final review completed. Terraform code generation workflow finished successfully.",
        additional_kwargs={"agent": "reviewer", "step": "review_completed", "status": "success"}
    )
    state["messages"].append(review_message)
    
    return state


def should_continue_validation(state: TerraformState) -> Literal["continue", "complete", "analyze"]:
    """Determine next step after validation"""
    
    validation_results = state.get("validation_results", [])
    iteration_count = state.get("iteration_count", 0)
    max_iterations = state.get("max_iterations", 5)
    
    # Check if we've hit max iterations
    if iteration_count >= max_iterations:
        return "complete"
    
    # Check validation results
    if not validation_results:
        return "analyze"  # No validation results yet, run analysis
    
    # Check if all validations passed
    all_passed = all(result.passed for result in validation_results)
    
    if all_passed:
        return "complete"
    
    # Check for critical failures that need analysis
    critical_failures = [
        result for result in validation_results 
        if not result.passed and "critical" in str(result.errors).lower()
    ]
    
    if critical_failures:
        return "analyze"
    
    # Continue with refinement
    return "continue"


def should_continue_after_analysis(state: TerraformState) -> Literal["refine", "complete"]:
    """Determine next step after analysis"""
    
    analysis_results = state.get("analysis_results", {})
    
    # Check if analysis found issues that need fixing
    issues_found = analysis_results.get("issues_found", [])
    
    if issues_found:
        return "refine"
    
    return "complete" 